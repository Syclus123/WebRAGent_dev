"""
This script is used to parse the operator log file generated by the operator system.
"""
import re
import json
import os
import ast

class OperatorLogProcessor:
    def __init__(self, log_file_path, task_mapping_file=None):
        self.log_file_path = log_file_path
        
        # Get the task mapping file path from the configuration file
        config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'configs/log_config.json')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
                default_mapping_file = config.get('task_mapping_file', '')
        except Exception:
            default_mapping_file = ''
        
        self.task_mapping_file = task_mapping_file or default_mapping_file or os.path.join(os.path.dirname(os.path.dirname(__file__)), 'data/Online-Mind2Web/Online_Mind2Web.json')
        self.task_mapping = self._load_task_mapping()

    def _load_task_mapping(self):
        """ Load task mapping file """
        try:
            with open(self.task_mapping_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Failed to load the task mapping file: {e}")
            return []

    def _get_task_id_by_task_name(self, task_name):
        """Get task ID by task name"""
        if not task_name:
            return ''
            
        for task in self.task_mapping:
            if task.get('confirmed_task') == task_name:
                return task.get('task_id', '')
        return ''

    def _parse_operator_action(self, action_dict):
        """Parse operator action to readable format"""
        if not action_dict:
            return ""
        
        action_type = action_dict.get('type', '')
        if action_type == 'click':
            x = action_dict.get('x', '')
            y = action_dict.get('y', '')
            button = action_dict.get('button', 'left')
            return f"click({x}, {y}, {button})"
        elif action_type == 'type':
            text = action_dict.get('text', '')
            return f"type('{text}')"
        elif action_type == 'scroll':
            direction = action_dict.get('direction', '')
            return f"scroll({direction})"
        elif action_type == 'wait':
            return "wait"
        elif action_type == 'screenshot':
            return "screenshot"
        else:
            return f"{action_type}"

    def parse_log(self):
        """Parse the operator log file and extract the information"""
        result = {
            "task_id": "",
            "task": "",
            "final_result_response": "",
            "action_history": [],
            "thoughts": []
        }

        try:
            with open(self.log_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract task name
            task_patterns = [
                r'task_name: (.+?)(?:\n|\r\n)',
                r'task: (.+?)(?:\n|\r\n)',
                r'"task": "([^"]+)"'
            ]
            
            for pattern in task_patterns:
                task_match = re.search(pattern, content)
                if task_match:
                    result["task"] = task_match.group(1).strip()
                    result["task_id"] = self._get_task_id_by_task_name(result["task"])
                    if result["task_id"]:
                        break
            
            # Extract Step Action and Step Thought from log
            # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…Step Actionå’ŒStep Thoughtçš„æ¨¡å¼
            step_pattern = r'Step Action: (\{.*?\})\s*(?=\n\d{4}-\d{2}-\d{2}|\nStep|\nğŸ“|\Z)'
            thought_pattern = r'Step Thought: (.+?)(?=\n\d{4}-\d{2}-\d{2}|\nStep|\nğŸ“|\nStep Action|\Z)'
            
            # æå–æ‰€æœ‰Step Action
            step_actions = re.findall(step_pattern, content, re.DOTALL)
            for action_str in step_actions:
                try:
                    # ä½¿ç”¨ast.literal_evalè§£æPythonå­—å…¸æ ¼å¼
                    action_dict = ast.literal_eval(action_str)
                    action = action_dict.get('action', '')
                    action_input = action_dict.get('action_input', '')
                    
                    # æ‹¼æ¥actionå’Œaction_input
                    if action and action_input:
                        action_desc = f"{action}({action_input})"
                    elif action:
                        action_desc = action
                    else:
                        action_desc = action_input
                    
                    if action_desc:
                        result["action_history"].append(action_desc)
                        
                except (ValueError, SyntaxError) as e:
                    print(f"Failed to parse step action: {e}")
                    continue
            
            # æå–æ‰€æœ‰Step Thought
            thought_matches = re.findall(thought_pattern, content, re.DOTALL)
            for thought in thought_matches:
                thought_clean = thought.strip()
                if thought_clean and thought_clean not in result["thoughts"]:
                    result["thoughts"].append(thought_clean)
            
            # Extract Final Status
            final_status_match = re.search(r'Final Status: (.+?)(?:\n|\r\n|\Z)', content)
            if final_status_match:
                result["final_result_response"] = final_status_match.group(1).strip()
            else:
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°Final Statusï¼Œä½¿ç”¨é»˜è®¤å€¼
                if result["thoughts"]:
                    result["final_result_response"] = result["thoughts"][-1]
                elif result["action_history"]:
                    result["final_result_response"] = result["action_history"][-1]
                else:
                    result["final_result_response"] = "Task completed"
                    
        except Exception as e:
            print(f"Error parsing operator log file: {e}")
        
        return result 